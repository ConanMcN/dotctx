# Project Guidelines

## Current
Branch: main
Task: Workflow improvements — auto-compile, git hooks, MCP resources/prompts
State: done
Next: Add more adapters, improve token counting accuracy, add tests for new features
Files: src/utils/autocompile.ts, src/commands/hooks.ts, src/bin.ts, src/commands/decide.ts, src/commands/landmine.ts, src/commands/vocab.ts, src/commands/loop.ts, src/commands/push.ts, src/commands/prune.ts, src/commands/init.ts, src/mcp/server.ts, src/mcp/tools.ts, README.md

## Landmines
- [D] `console.error` instead of `console.log` in serve command (src/commands/serve.ts:10) — [D] MCP server uses stdout for stdio transport — any console.log would corrupt the protocol
- [D] `extractKeywords` function duplicated in capsule.ts and preflight.ts (src/core/capsule.ts:6, src/core/preflight.ts:3) — [D] Intentional — these modules are independent and may diverge; extracting a shared util would create coupling
- [D] `tokenizer.ts` re-exports from `utils/tokens.ts` (src/core/tokenizer.ts) — [D] Part of the public core API surface — provides `allocateBudget()` alongside re-exported token utils
- MCP server version hardcoded to `0.1.0` (differs from package version) (src/mcp/server.ts:15) — MCP protocol version is intentionally decoupled from package version — MCP spec version, not release version
- `autoCompile` uses `{ silent: true }` in MCP tools but not in CLI commands (src/mcp/tools.ts) — MCP uses stdio — compile output would corrupt the protocol; CLI commands should show user feedback

## Decisions
- ESM-only package (`"type": "module"`) (over: CJS, dual CJS+ESM) — [D] Simpler build, modern Node.js, aligns with MCP SDK - Zod for schema validation (over: io-ts, Ajv, manual validation) — [D] Co-locates schema + type derivation, good DX with `.parse()` - commander for CLI (over: yargs, oclif, citty) — [D] Lightweight, well-known, subcommand support - tsup for bundling (over: esbuild direct, Rollup, tsc-only) — [D] Zero-config TS→ESM, handles shims and DTS generation - Word-based token approximation (1.3x) (over: tiktoken, exact BPE counting) — [D] Zero dependencies, fast, good enough for budget allocation - File-based context (`.ctx/` directory) (over: Database, JSON single-file, API) — [D] Git-trackable, human-editable, tool-agnostic, zero infrastructure - Manual markdown table parsing (over: remark, markdown-it, unified) — [D] Tables are simple/predictable, avoids heavy AST dependency - Renamed package to `dotctx` (over: Keep `aictx`) — [D] `aictx` was taken on npm; `dotctx` reflects the `.ctx/` convention - Dual bin names (`dotctx` + `aictx`) (over: Single name only) — [D] `aictx` alias preserved for backwards compatibility - Priority-based token allocation (over: Equal allocation, percentage-based) — [D] Critical sections (current, landmines) get uncapped space, lower-priority sections share remainder - Adapter pattern for output formats (over: Single output, template strings) — [D] Each AI tool (Claude, Cursor, Copilot) has different conventions; adapters encapsulate format differences - Auto-compile after mutations (over: Manual compile only, file watchers) — Keeps context files in sync without extra steps; --no-compile escape hatch for hooks/scripts - Git hook uses `npx --yes` with `exit 0` (over: Direct binary path, husky) — Works whether installed globally or locally; never blocks commits - MCP resources for passive context (over: Tools-only MCP) — Resources let MCP clients auto-read context without explicit tool calls - Dynamic CLI version from package.json (over: Hardcoded version string)

[...truncated to fit budget]

## Conventions
# Conventions ## Patterns <!-- [D] Derived from code analysis --> - File naming: kebab-case for all source files (e.g., `open-loops.yaml`, `capsule.ts`) [D] - Exports: named exports only — no default exports anywhere in the codebase [D] - Command registration: each command file exports a `register<Name>(program: Command)` function [D] - Barrel files: `src/index.ts` re-exports public API, `src/core/adapters/index.ts` re-exports adapters, `src/templates/index.ts` re-exports templates [D] - Zod-first types: schemas defined in `types.ts` with Zod, TypeScript types derived via `z.infer<>` [D] - ESM imports: all internal imports use `.js` extension (required for ESM + TypeScript bundler resolution) [D] - Date format: ISO date string `YYYY-MM-DD` used everywhere (`.split('T')[0]` pattern) [D] - CLI output: `picocolors` for terminal colors, `pc.green('✓')` for success, `pc.red()` for errors [D] - Error handling: commands check `findCtxDir()` and exit early with error message if no `.ctx/` found [D] - YAML I/O: centralized in `utils/yaml.ts` with `readYaml<T>()` / `writeYaml()` [D] - Markdown tables: parsed manually in `loader.ts` — pipe-delimited, skipping header/separator rows [D] - Mutation commands: call `autoCompile(ctxDir)` after writing, support `--no-compile` flag to skip - MCP autocompile: use `autoCompile(ctxDir, { silent: true })` — never print to stdout in MCP context - CLI version: read dynamically from `package.json` via `createRequire` — never hardcode ## Anti-patterns <!-- [D] Inferred from codebase patterns --> - Don't use default exports — this project uses named exports everywhere [D] - Don't import from `node:*` without the `node:` prefix — this is an ESM project [D] - Don't omit `.js` extension on relative imports — ESM resolution requires it [D] - Don't add CommonJS output — the project is ESM-only (`"type": "module"`) [D] - Don't use `console.log` in MCP server stdout — MCP uses stdio for communication, use `console.error` [D] - Don't hardcode version strings — read from `package.json` at runtime - Don't forget `autoCompile()` when adding new mutation commands ## AI failure modes <!-- [D] Common issues AI models would hit in this codebase --> - Models forget `.js` extensions on imports and write `from './loader'` instead of `from './loader.js'` [D] - Models suggest

[...truncated to fit budget]

## Architecture
# Architecture ## Key paths <!-- [D] Derived from directory scan --> | Path | Purpose | |------|---------| | `src/bin.ts` | [D] CLI entry point — registers all commander commands, reads version from package.json | | `src/index.ts` | [D] Library entry point — public API exports | | `src/types.ts` | [D] All Zod schemas, TypeScript types, and interfaces | | `src/commands/` | [D] CLI command handlers (one file per command, `register*` pattern) | | `src/commands/hooks.ts` | Git hook install/uninstall (post-commit) | | `src/core/` | [D] Core logic: compiler, capsule generator, loader, precedence, freshness | | `src/core/adapters/` | [D] Output adapters: claude, cursor, copilot, system | | `src/mcp/` | [D] MCP server (stdio transport), tools, resources, and prompts | | `src/templates/` | [D] Scaffold templates for `init` and the ctx-setup skill prompt | | `src/utils/` | [D] Helpers: git, markdown parsing, token counting, YAML I/O, autocompile | | `src/utils/autocompile.ts` | Auto-recompile all adapters after mutation commands | | `src/__tests__/` | [D] Vitest unit tests | | `.ctx/` | [D] The context

[...truncated to fit budget]

## Vocabulary
- **capsule**: [D] A compiled, token-budgeted, task-specific context blob generated from `.ctx/` files — NOT a UI component or database concept - **landmine**: [D] Code that looks wrong but is intentionally that way — a "don't touch" marker, NOT a bug or security issue - **loop (open loop)**: [D] An unfinished thread of work with a TTL (time-to-live) — NOT a programming loop construct - **preflight**: [D] A pre-coding checklist of relevant landmines, decisions, and ripple effects for a specific task — NOT a CORS

[...truncated to fit budget]

## AI Context
This project uses `.ctx/` for structured context. Run `aictx pull --task "..."` for task-specific context.
Check `.ctx/landmines.md` before changing code that looks wrong.